## 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/64063

## 유형

유니온 파인드, 경로 압축

## 풀이법

만약 이어지는 구간이 발생한다면, 그만큼 건너뛰어서 다음 수를 찾아야 하므로 유니온 파인드와 특히 경로 압축 알고리즘이 중요했다.

10^12개의 방이 존재하기 때문에, 배열로 부모 방을 기록하면 메모리가 터진다.

반면 총 요청하개 되는 방의 수는 10^5 정도이므로, HashMap을 사용해서 요청이 들어온 방들에 대해서 부모 방을 기록했다.

만약 요청이 들어온 방이 Map에 존재하지 않는다면, 바로 방을 배정하고 map에 (방 번호, 방 번호 + 1) 형식으로 기록한다.

만약 요청이 들어온 방이 Map에 이미 존재한다면, 부모 방까지 최대한 타고 간 다음에 더 이상 부모 방이 없다면, 해당 방을 배정해주고 map에 (방 번호, 방번호 + 1)을 기록한다.

하지만 여기서 경로 압축 메커니즘이 중요한데,

이렇게 타고 온 방들에 대해서 다음 번에도 계산을 진행한다면 시간 초과가 발생할 것이다. Map의 길이가 최대 10^5가 될 수 있기 때문에.

그래서 부모를 타고 가면서 list에 방문한 방들의 히스토리를 기록하고, 이 방 전체들에 대해서도 부모 방을 최종 방으로 변경하는 작업을 수행한다.

## 메모리 / 수행시간 / 코드길이