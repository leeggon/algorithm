## 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/68646

## 유형

구현

## 풀이법

10^6의 범위이기 때문에 모든 풍선을 터트리는 완전 탐색을 할 수는 없었다.

문제 조건 중에서 번호가 작은 풍선을 1번만 터트릴 수 있다는 조건이 있어서, 이것을 활용해야 했다.

풍선이 3개일 경우에 총 4가지 경우의 수에 대해 생각해봤다.

1. 왼작 오큰 (1 2 3)
2. 왼큰 오작 (3 2 1)
3. 왼큰 오큰 (1 3 2)
4. 왼작 오작 (3 1 2)

다른 모든 경우의 수에는 모든 풍선들이 끝까지 생존 가능했지만,

3번 경우에서 가장 큰 번호의 풍선은 생존이 불가능했다. 그 이유는 항상 큰 풍선을 터트려야 하고, 작은 풍선은 1번만 터트릴 수 있는데 해당 경우에는 작은 풍선을 2번 터트려야 하기 때문이다.

이것은 풍선이 3개가 아니라 더욱 커지는 경우에도 동일하게 적용될 것이라 생각했다.

왼쪽 풍선들이나 오른쪽 풍선들은 계속해서 큰 풍선을 위주로 지우기 때문에 결국엔 각각의 최소값들이 남게 된다.

이 왼쪽 최소값과 오른쪽 최소값 모두보다 중간의 풍선이 크다면, 어떻게 해서도 지울 수 없는 풍선이 되어버린다.

leftMin 배열: 내보다 왼쪽 애들 중에 최소값

rightMin 배열: 내보다 오른쪽 애들 중에 최소값

2가지 배열을 만들고, 이 두 값보다 a[i]가 큰 경우에 count를 해주어 풀이했다.

## 메모리 / 수행시간 / 코드길이