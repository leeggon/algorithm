## 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/49191

## 유형

플로이드 워샬

## 풀이법

플로이드 워샬 알고리즘을 처음으로 공부해봤다. (처음에 위상 정렬 등의 풀이를 생각했지만, 풀이가 쉽지 않았다.)

다익스트라 알고리즘이 하나의 정점에서 모든 정점으로의 최단 경로를 계산하는 알고리즘이라면,

플로이드 워샬 알고리즘은 모든 정점에서 모든 정점까지로의 최단 경로를 계산하는 알고리즘이다.

특징으로는

1. DP 기반으로 동작
2. 음수 가중치도 가능
3. O(N^3)의 시간 복잡도를 가진다. (여기서 N은 정점의 개수이다.)
4. 경유지를 하나씩 추가하면서 최단 경로를 갱신한다.

풀이 방법은

1. 그래프를 행렬로 표현 <br> dist[i][j] : i에서 j로 가는 최단거리 (초기에는 간선 정보를 그대로 저장)
2. 모든 정점을 한번씩 경유지로 설정하면서 최단 거리를 갱신한다. <br> dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) <br> 즉 i->j 로 가는 기존 경로보다 i -> k -> j 경로가 더 짧으면 갱신한다.
3. 모든 정점 쌍에 대해 반복하며 최단거리 행렬을 갱신함.


이 문제는 1대1 방식으로 두 복서의 승패만 결정지으면 되었다.

따라서 최소 거리 2차원 그래프 행렬을 만들어두고, 이기는 상황은 1, 지는 상황은 -1로 초기에 기록했다.

이후에, k=1부터 k=n까지 각 경유지에 대해서 생각한다.

i -> k (dist[i][k] == 1) && k -> j (dist[k][j] == 1) 인 상황이라면, dist[i][j] = 1로 업데이트 해준다.

완성된 최단 거리 행렬을 봤을 때, 자신을 제외한 n-1 정점과의 승패가 1이나 -1로 정해져있다면, 그 사람의 순위는 정해진 것이므로 answer++를 해주어서 총 순위 판별 가능한 복서의 수를 계산했다. 


## 메모리 / 수행시간 / 코드길이